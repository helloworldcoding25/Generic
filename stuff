def cross_sectional_ridge(eps_hat: np.ndarray,
                          beta:    np.ndarray,
                          lam:     float | None = None,
                          return_gross: bool = True):
    """
    Cross-sectional ridge solve:
        argmin_F  || eps_hat + beta @ F ||^2 + lam * ||F||^2

    Parameters
    ----------
    eps_hat : (N,)  idiosyncratic %-return predictions
    beta    : (N, L) factor-loading matrix
    lam     : ridge penalty; default = 1e-4 * N   (good first guess)
    return_gross : also return eps_hat + beta @ F_hat if True

    Returns
    -------
    F_hat : (L,)  inferred factor % returns
    gross_pred  (optional) : (N,) gross % forecast per bond
    """
    eps_hat = np.asarray(eps_hat, dtype=float)
    beta    = np.asarray(beta,    dtype=float)
    N, L    = beta.shape

    # sensible default for lambda
    if lam is None:
        lam = 1e-4 * N

    A = beta.T @ beta + lam * np.eye(L)       # (L,L)
    b = -beta.T @ eps_hat                     # (L,)

    F_hat = np.linalg.solve(A, b)             # (L,)

    if return_gross:
        gross_pred = eps_hat + beta @ F_hat   # (N,)
        return F_hat, gross_pred
    return F_hat


import pandas as pd
import numpy as np

def calc_distribution_averages(df1, df2, n_buckets=10):
    """
    Calculate average values of df2 across the distribution of df1,
    using fully vectorized operations for maximum performance.
    
    Parameters:
    df1, df2: pandas DataFrames with same shape
    n_buckets: number of buckets to create
    
    Returns:
    DataFrame with buckets as index and average values as columns
    """
    # Calculate quantile boundaries across all values
    all_values = df1.values.ravel()
    boundaries = np.percentile(all_values, 
                             np.linspace(0, 100, n_buckets + 1),
                             method='linear')
    
    # Vectorized bucket assignment for entire DataFrame
    bucket_indices = np.digitize(df1.values, boundaries[1:-1])
    
    # Create a DataFrame of bucket assignments
    buckets_df = pd.DataFrame(bucket_indices, 
                             index=df1.index,
                             columns=df1.columns)
    
    # Stack both DataFrames to long format for vectorized groupby
    stacked_buckets = buckets_df.stack()
    stacked_values = df2.stack()
    
    # Perform groupby operation once for all columns
    result = (pd.DataFrame({'bucket': stacked_buckets, 'value': stacked_values})
             .groupby(['bucket'])['value']
             .mean()
             .reset_index())
    
    # Reshape back to original format
    result = (result.pivot(columns='bucket', values='value')
             .rename(columns={i: f'Q{i+1}' for i in range(n_buckets)})
             .T)
    
    return result

import pandas as pd
import numpy as np

def process_group(df_group):
    """
    Process a single ISIN group (already sorted by time) and simulate the sequential
    impact of candidate trades. Returns extra columns:
      - risk_reducing: bool indicating if that trade would have reduced risk
      - candidate_effect: using the 'size' column (which equals posPost - posPre)
      - simulated_start_before: simulation state (starting position) before the trade
      - simulated_final_after: simulation state (final position) after the trade if applied
      - abs_improvement: improvement in |position| from applying this trade
    """
    # Sort by time.
    df_group = df_group.sort_values('time').copy()
    n = len(df_group)
    
    # Extract arrays for speed.
    times = df_group['time'].values
    posPre_arr = df_group['posPre'].values
    posPost_arr = df_group['posPost'].values
    doneStatus_arr = df_group['status'].values
    size_arr = df_group['size'].values  # Using the provided size column directly

    # Use size as the candidate effect.
    cand_effect = size_arr.copy()

    # Allocate output arrays.
    risk_reducing = np.zeros(n, dtype=bool)
    simulated_start_before = np.empty(n, dtype=posPre_arr.dtype)
    simulated_final_after = np.empty(n, dtype=posPre_arr.dtype)
    abs_improvement = np.zeros(n, dtype=posPre_arr.dtype)
    
    # Determine the baseline simulation state.
    # Look for the last DONE trade.
    final_trade_index = None
    for i in range(n):
        if doneStatus_arr[i] == 'DONE':
            final_trade_index = i  # will update to the last DONE trade index

    if final_trade_index is not None:
        # For a DONE trade, use its posPre as the baseline start,
        # and use its posPost directly as the baseline final.
        fixed_effect = posPost_arr[final_trade_index] - posPre_arr[final_trade_index]
        baseline_start = posPre_arr[final_trade_index]
        baseline_final = posPost_arr[final_trade_index]
    else:
        fixed_effect = 0.0
        baseline_start = posPre_arr[0]
        baseline_final = baseline_start

    # Initialize simulation state.
    current_start = baseline_start
    current_final = baseline_final

    # Process each row sequentially.
    for i in range(n):
        simulated_start_before[i] = current_start
        # In the DONE-case, only simulate for trades before the final DONE trade.
        if (final_trade_index is not None) and (i >= final_trade_index):
            # For trades at or after the final DONE trade, we do not simulate.
            simulated_final_after[i] = current_final
            abs_improvement[i] = 0.0
            risk_reducing[i] = False
        else:
            new_start = current_start + cand_effect[i]
            # In the DONE-case, the final position is updated by adding the fixed effect.
            # In the no-DONE-case, fixed_effect is 0.
            new_final = new_start + fixed_effect
            improvement = abs(current_final) - abs(new_final)
            if improvement > 0:
                risk_reducing[i] = True
                # Update the simulation state.
                current_start = new_start
                current_final = new_final
                abs_improvement[i] = improvement
            else:
                risk_reducing[i] = False
                abs_improvement[i] = 0.0
            simulated_final_after[i] = current_final

    # Attach the computed arrays as new columns.
    df_group['risk_reducing'] = risk_reducing
    df_group['candidate_effect'] = cand_effect
    df_group['simulated_start_before'] = simulated_start_before
    df_group['simulated_final_after'] = simulated_final_after
    df_group['abs_improvement'] = abs_improvement

    return df_group

def add_risk_reducing_info(df):
    """
    Process the entire dataframe by ISIN and return the dataframe with additional
    columns that indicate for each row if that trade would have been risk reducing and
    how that conclusion was reached.
    """
    # Process by ISIN groups.
    df_with_info = df.groupby('isin', group_keys=False).apply(process_group)
    return df_with_info

import numpy as np

